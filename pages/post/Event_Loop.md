---
title: '深入理解 JavaScript 事件循环机制与异步原理'
date: '2024-11-25'
---
# 深入理解 JavaScript 事件循环机制与异步原理

## 进程

一言以蔽之：程序运行的专属的内存空间。

每一个程序至少有一个进程，且进程之间相互独立，通信需要双方同意。启动时分配。

## 线程

一言以蔽之：运行代码的“人”就是线程。

一个进程至少需要一个线程，没有线程的进程会被自动删除。进程启动时会自动创建线程来运行代码，称之为主线程。主线程结束，整个程序就结束了。程序有时需要执行多块代码，主线程忙不过来就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。线程可以同时进行。

## 浏览器的进程和线程

一言以蔽之：浏览器是一个多进程多线程的应用程序。

浏览器进程、网络进程、渲染进程……互不干扰。

- 浏览器进程：负责浏览器的显示，用户交互，子进程管理等。其他进程会由浏览器进程启动。
- 网络进程：处理网络任务。
- 渲染进程：进程启动，开启渲染主线程，负责执行 HTML、CSS、JS 代码。默认情况下每一个标签页就会有一个渲染进程，保证互不影响。

## 渲染主线程如何工作

渲染主线程会通过队列来处理问题（message queue）。正在执行的任务或其他线程有可能会产生新的任务，新的任务会被放在队列里。当正在执行的任务完成之后才会从队列中获取新的任务。最开始时，渲染主线程会进入到一个无限循环， 每一次循环都会检测队列是否有任务，没有任务就会进入休眠。其他所有线程（包括线程的进程）都可以向消息队列中添加新任务。添加新任务时会将其唤醒。

## 何为异步

无法立即执行的任务例如：计时器、网络通信完成后执行的任务，用户操作后的任务。如果让渲染主线程等待这些任务，会导致主线程长期处于阻塞状态，导致浏览器卡死。

异步执行：计时器开始，通知计时线程计时，当前任务结束，继续执行下面的任务。等到计时任务结束，将回调函数放回到消息队列的末尾，顺序执行。

**如何理解异步**:JS 是单线程，运行在浏览器的渲染主线程，渲染主线程只有一个，而渲染主线程承担很多工作，包括执行 JS。如果使用同步就可能会导致主线程阻塞，导致消息队列中的其他任务无法执行，导致浏览器卡死。

浏览器采用异步方式来避免。当某些异步任务开始执行，主线程将任务交给其他线程，自身立即结束该任务并执行后续任务。其他线程完成后，会将回调函数包装成任务，加入到消息队列的末尾，等待主线程调度执行。保证浏览器永不阻塞，保证单线程稳步执行。

## JS 为什么会阻碍渲染

```JavaScript
var h1 = document.querySelector('h1')
var btn = document.querySelector('button')

btn.onclick = function() {
h1.textContent = 'Hello'
sleep(3000)
}
```

渲染主线程执行全局 JS，给 button 添加点击事件。用户点击按钮之后，首先修改了 h1 的内容，会生成一个绘制任务并存入消息队列中，之后在 sleep（3000）方法中会出现一个死循环，渲染主线程要一直执行这个死循环三秒后，才会从消息队列中拿到绘制任务然后执行。

## 任务有没有优先级

任务是没有优先级的，在消息队列中都是先进先出。但是消息队列存在优先级。每一个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。浏览器会根据实际情况从不同队列中取出任务执行。

浏览器必须准备好一个微队列，微队列中的任务优先于所有其他任务。

队列主要包含：延时队列（计时器）（优先级较高）、交互队列（用户操作 优先级较低）、微队列（优先级最高）等。

添加到微队列主要是使用：Promise，mutationObserver。

```JavaScript
Promise.resolve().then(func)
//func直接进入微队列
```

```JS
setTimeout(()=>{
console.log(1)
},0)

console.log(2)
// 2 1
```

渲染主线程执行 JS->计时器，放入计时线程，主线程中任务结束 0 秒后回调函数包装成任务进入到队列->输出 2->输出 1

```JS
function delay(duration) {
var start = Date.now()
while(Date.now()-start<duration) {}
}

setTimeout(function() {
console.log(1)
},0)

delay(1000)
console.log(2)
// 等待1秒后 2 1
```

渲染主线程执行 JS->计时器，放入计时线程 主线程内计时任务结束 任务结束 0 秒后进入延时队列 ->delay 执行 线程死循环 1 秒 ->阻塞结束 先执行全局 JS 输出 2 ->再执行延时队列 输出 1

```JS
setTimeout(function() {
console.log(1)
},0)

Promise.resolve().then(function() {
console.log(2)
})

console.log(3)
// 3 2 1
```

渲染主线程执行 JS->计时器，放入计时线程 主线程内计时任务结束 任务结束 0 秒后进入延时队列->Promise 将函数放入到微队列->输出 3->执行微队列任务 输出 2 ->执行延时队列任务 输出 1

**阐述一下 JS 的事件循环**
JS 的事件循环又叫消息循环（浏览器内部实现的名称），是浏览器渲染主线程的工作方式。在渲染主线程开始后会开启一个不会结束的 for 循环，每一次循环从消息队列取出第一个任务来执行，而其他线程只需在合适的时候将任务加到队列的末尾即可。

过去将队列分为宏队列，微队列，但这种说法目前已经无法满足复杂的浏览器环境，取而代之的是，给每个任务加上不同的类型，相同类型的任务必须在一个队列里面，不同类型的任务也可以在一个队列中。不同队列有不同的优先级，由浏览器决定取哪一个队列的任务。但是浏览器必须有一个微队列且微队列的优先级最高。在浏览器中为了保证用户体验，会保证交互队列优先执行。

**JS 中计时器能精确计时吗？**
不行。

1. 计算机硬件没有原子钟，无法做到精确计时。
2. 操作系统计时函数本身存在少量偏差，而 JS 计时器最终是调用操作系统的函数
3. 根据 W3C 的标准，计时器嵌套超过五层会有 4 毫秒的延时。
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行。（计时器进入延时队列）

## 总结

单线程是异步产生的原因，事件循环是异步的实现方式。
